:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная №1
=== Задание 1
Создадим новый С++ проект  _Kproject3_ под микроконтроллер *STM32F411RE* и программатор *ST-Link/V2* в IDE *IAR Embedded Workbench*, загрузим в него файлы из проекта преподавателя (https://github.com/lamer0k/stm32Labs/tree/master/Lab1).

Необходимо привести структуру рабочей области проекта _Kproject3_ в соответствие со структурой проекта преподавателя.
Для этого создаем в рабочей области следующие группы (_Add - Add Group..._):

* _AbstractHardware/Registers/STM32F411_;
* _AbstractHardware/Registers/CortexM4_;
* _AbstractHardware/Registers/STM32F411/FieldValues_;
* _AbstractHardware/Registers/CortexM4/FieldValues_;
* _Common_;

и добавляем в проект скаченные файлы (_Add - Add Files..._): _starupF414RE.cpp_ и другие.

В результате проект принимает структуру, привиденную на рисунке 1.

.Структура проекта
image::file1.png[]

Укажем директории размещения файлов проекта в настройках препроцессора (рисунок 2).

.Добавление директорий
image::file2.png[]
Настроим объем памяти, занимаемый _Stack_ и _Heap_. Для этого в меню _Options-Linker_ снимем галочку с пункта _Override default_, нажмём _Edit..._ и отведем по 0x1000 байт для _Stack_ и _Heap_ (рисунок 3).

.Настройка STACK/HEAP
image::file3.png[]

В файл _main.cpp_ запишем следующий код:
----
#include "gpiocregisters.hpp" //for GPIOC
#include "rccregisters.hpp"   //for RCC

int main()
{
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::ODR::ODR5::Enable::Set() ;
  GPIOC::ODR::ODR5::Disable::Set() ;
  return 0 ;
}
----
Видим, что в коде для обращения к регистрам используется  некоторая незнакомая библиотека. По названиям упоминаемых в коде регистров и https://www.st.com/resource/en/reference_manual/dm00119316-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf[_Reference Manual for STM32F411RE_], а так же по схеме платы *XNucleo-F411RE* (рисунок 4) можно судить о назначении строк кода:

. включается тактирование порта GPIOС;
. GPIOC5 переводится в режим порта вывода;
. на выходе GPIOC5 устанавливается 1 (и, как следует из рисунка 4, загорается светодиод _User_LED4_).
. на выходе GPIOC5 устанавливается 0 (и светодиод _User_LED4_ гаснет).

.Схема платы XNucleo-F411RE
image::file4.png[]
=== Задание 2
Соберем проект (_Project-Rebuild All_). Сборка провалилась (рисунок 5).

.Ошибка при сборке проекта
image::file5.png[]
Перейдем к определению _GPIOC::ODR::ODR5_, чтобы разобраться в произошедшей ошибке. Узнаем, что _GPIOC::ODR::ODR5_ является псевдонимом для структуры _GPIOC_ODR_ODR5_Values_, имеющей следующее определение:
----
template <typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct GPIOC_ODR_ODR5_Values: public RegisterField<Reg, offset, size, AccessMode>
{
  using Low = FieldValue<GPIOC_ODR_ODR5_Values, BaseType, 0U> ;
  using High = FieldValue<GPIOC_ODR_ODR5_Values, BaseType, 1U> ;
} ;
----
Очевидно, что для _Enable_ и _Disable_ нет определения,  их упоминания в _main.cpp_ следует заменить  на _High_ и _Low_.
Исправленный код в _main.cpp_:
----
#include "gpiocregisters.hpp" //for GPIOC
#include "rccregisters.hpp"   //for RCC

int main()
{
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::ODR::ODR5::High::Set() ;
  GPIOC::ODR::ODR5::Low::Set() ;
  return 0 ;
}
----
Соберем проект (сборка проходит успешно), загрузим програму в микроконтроллер. Так как между ожидаемыми включением и выключением светодиода не задана задержка, его включение можно зафиксировать только в режиме построчной отладки.

Действительно, при работе программы загорается светодиод _User_LED4_ (рисунок 6).

.Включение светодиода _User_LED4_
image::file6.png[100,300]
=== Задание 3
Задание предусматривает работу с анализатором стека. Для того, чтобы включить опцию анализа глубины стека, необходимо перейти в _Options - Linker - Advanced_ и поставить галочку _Enable stack usage analysis_ (рисунок 7). Затем пересоберем проект, и в файле _.map_ появится запись с результатами анализа стека (рисунок 7).

.Выдержка из файла _.map_
image::file7.png[]

Таким образом, при максимальной цепочке вложенности размер стека  может быть равным 16 байт.

Далее задание требует установить нулевым размер _Heap_. Сконфигурируем линкёр соответствующим образом (рисунок 8).

.Установка нулевого размера _Heap_
image::file8.png[600,600]

Сборка проходит успешно - память в программе не аллоцируется динамически - соответственно, нет и переменных, хранящихся на _Heap_.
В отличие от _Heap_, _Stack_ используется в любом случае: здесь хранятся локальные переменные и адреса возвратов функций, и следовательно, нельзя выделять под _Stack_ нулевой объем памяти.

=== Ответы на вопросы

[red]#_1. Дайте определение понятию “Интегрированная среда разработки”_#

*Интегрированная среда разработки* - это совокупность программных средств, поддерживающая все этапы разработки ПО (от написания исходного текста программы до ее компиляции и отладки) и обеспечивающая простое взаимодействие с другими программными средствами (отладчиком-симулятором,  программатором).

[red]#_2. Что такое компилятор и чем он отличается от транслятора?_#

*Транслятор* – это программа-переводчик. Она преобразует программу, написанную на одном языке программирования, в программу на другом языке. Трансляция может осуществляться без исполнения транслируемого кода (компиляция) или с исполнением (интерпретация). Трансляторы реализуются в виде: компиляторов, интерпретаторов, препроцессоров и эмуляторов.

*Компилятор* (англ. compiler – собиратель) –   разновидность транслятора, переводящая текст программы на машинно-ориентированный язык без построчного испонения кода. На выходе компилятора – бинарные файлы, содержащие перечень машинных команд. Бинарные файлы могут быть исполняемыми, библиотечными, объектными; впоследствии они выполняются операционной системой без участия компилятора. Компоновку машинно-ориентированной программы из сгенерированных на фазе трансляции объектных файлов компилятор обычно поручает компоновщику.

[red]#_3. Что такое компоновщик и какие функции он выполняет?_#

*Компоновщик* (редактор связей, link editor, linker) – программа, предназначенная для связывания между собой объектных файлов, порождаемых компилятором, а также файлов библиотек, входящих в состав системы программирования.

*Функции компоновщика:*

- компонует различные объектные файлы;
- устанавливает связи между объявлением функции или переменной с ее определением.

[red]#_4. Почему важен процесс проектирования ПО и какие задачи входят в этот процесс?_#

Проектируя ПО, разработчик получает возможность:

- оценить  время и стоимость разработки программного продукта;
- исключить потери времени на ненужные действия, вынужденные доработки, длительное согласование;
- избежать разногласий и неудовлетворённости заказчика и исполнителя.

Проектирование ПО начинается с четкой формулировки требований заказчика, подразумевает выработку типичных сценариев работы ПО, согласование плана действий и оценку сроков готовности. Целью проектирования является определение внутренних свойств системы и детализации её внешних свойств на основе выданных заказчиком требований.
Проектирование ПО включает следующие основные виды деятельности:

- выбор метода и стратегии решения;
- выбор представления внутренних данных;
- разработка основного алгоритма;
- документирование ПО;
- тестирование и подбор тестов;
- выбор представления входных данных.

[red]#_5. Дорисуйте процесс разработки ПО с учетом итеративности связей в этом процессе_#


.Процесс разработки ПО в IAR
image::file9.png[]

[red]#_6. Зачем нужная отладка и в каких случаях она применяется? Для чего применяются точки останова?_#

Отладка – это этап разработки программы, на котором обнаруживают, локализуют и устраняют ошибки.
При отладке ПО удобно использовать точки останова (breakpoint). По достижению отмеченой такой точкой строки программа прерывается – включается режим отладки, и пользователь может получить подробную информацию о происходящем, например, изучив значения локальных переменных, текущее состояние памяти, регистров.

[red]#_7. Какие еще важные характеристики IAR workbench можно добавить в таблицу "Характеристики IAR"?_#

- поддерживается работа с микроконтроллерами от многих производителей (и перечислить производителей);
- возможность запуска проекта в режиме симуляции выбранного микроконтроллера;
- большая база пользователей и документации.

