:imagesdir: Images
:figure-caption: Рисунок
:table-caption: Таблица

== Лабораторная №3

==== Создание проекта

Создадим новый С++ проект  *Kproject4*, настроим его под микроконтроллер *STM32F411RE* и программатор *ST-Link/V2*, сформируем структуру проекта, аналогичную описанной в https://github.com/ntsiopliakis/Lab1/blob/main/Report_Lab1.adoc[отчете по лабораторной работе №1].

==== Тактирование системной шины от внешнего высокочастотного генератора HSE

В файл *main.cpp* запишем следующий код (рисунок 1):

._Тактирование системной шины от генератора *HSE*_
image::file1.png[]
Таким образом описана следующая последовательность действий:

* Включение генератора *HSE*;
* Ожидание установки частоты *f~HSE~*;
* Выбор *HSE* источником тактирования системной шины;
* Ожидание завершения переключения системной шины на тактирование от *HSE*;
* Включение тактирования порта *GPIOС*;
* Установка линии  *GPIOC5* в режим вывода;
* Включение и выключение светодиода *User_LED4* в цикле установкой и сбросом потенциала на линии *GPIOC5*. Задержка между включением / выключением светодиода реализована пустым циклом *for*.

Для того, чтобы подобная реализация задержки работала, необходимо понизить уровень оптимизации кода компилятором (_Options - C/C\++ Compiler - Optimization - Level_). В противном случае пустые циклы будут удалены в рамках оптимизации, известной как *Dead Code Elimination, DCE*. За информацией об оптимизациях, используемых компилятором на различных уровнях оптимизации братимся к
http://www.iarsys.co.jp/download/LMS2/arm/7502/ewarm7502doc/arm/doc/EWARM_DevelopmentGuide.ENU.pdf#page=222[IAR
C/C++Development Guide for Arm: page 222,window=_blank]. Видим, что *DCE* используется на уровнях оптимизации *Medium* и выше. Тогда установим уровень оптимизации *Low*.

При загрузке программы в микроконтроллер наблюдается мигание светодиода с некоторой частотой (согласно https://www.waveshare.com/xnucleo-F411RE.htm[описанию платы XNUCLEO-F411RE,window=_blank] частота *f~HSE~* = 8 МГц).

==== Тактирование системной шины от внутреннего высокочастотного генератора HSI

В файл *main.cpp* запишем следующий код (рисунок 2):

._Тактирование системной шины от генератора HSI_
image::file2.png[]

Тактирование системной шины от генератора *HSI* настроено по умолчанию.

При загрузке программы в микроконтроллер наблюдается мигание светодиода с более высокой частотой, чем в прошлом пункте (согласно https://www.st.com/resource/en/reference_manual/dm00119316-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf#page=96[Reference manual for STM32F411xC/E,window=_blank] частота *f~HSI~* = 16 МГц).

==== Тактирование системной шины от системы ФАПЧ PLL частотой 32 МГц

В файл *main.cpp* запишем следующий код (рисунок 3):

._Тактирование системной шины от системы ФАПЧ PLL частотой 32 МГц_
image::file3.png[]

Согласно https://www.st.com/resource/en/reference_manual/dm00119316-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf#page=104[Reference manual for STM32F411xC/E,window=_blank], частота *PLL* на выводе общего назначения  задается как:
----
f(general clock output) = f(PLL clock input) × (PLLN / PLLM) / PLLP;
50 <= PLLN <= 432;
2 <= PLLM <= 63;
PLLP={2,4,6,8}.
----
По умолчанию на вход *PLL* поступает сигнал с *HSI*, *f~HSI~* = 16 МГц. *PLLP* по умолчанию равен двум, тогда требуемую частоту *f~PLL~* = 32 МГц обеспечит выбор *PLLN*=60, *PLLM* = 15.

При отладке были внесены изменения в файлы *rccregisters.hpp* и *rccfieldvalues.hpp*.

В первом файле:

[source, cpp]
struct PLLCFGR : public RegisterBase<0x40023804, 32, ReadWriteMode>
{
 using PLLQ0 = RCC_PLLCFGR_PLLQ_Values<RCC::PLLCFGR, 24, 4, ReadWriteMode, RCCPLLCFGRBase> ;
 using PLLSRC = RCC_PLLCFGR_PLLSRC_Values<RCC::PLLCFGR, 22, 1, ReadWriteMode, RCCPLLCFGRBase> ;
 using PLLP0 = RCC_PLLCFGR_PLLP_Values<RCC::PLLCFGR, 16, 2, ReadWriteMode, RCCPLLCFGRBase> ;
 using PLLN0 = RCC_PLLCFGR_PLLN_Values<RCC::PLLCFGR, 6, 9, ReadWriteMode, RCCPLLCFGRBase> ;
//using FieldValues = RCC_PLLCFGR_PLLM_Values<RCC::PLLCFGR, 0, 5, NoAccess, NoAccess> ; - было
 using PLLM0 = RCC_PLLCFGR_PLLM_Values<RCC::PLLCFGR, 0, 5, ReadWriteMode, RCCPLLCFGRBase> ;// - стало
  } ;

Во втором файле:
[source, cpp]
template <typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct RCC_CR_PLLRDY_Values: public RegisterField<Reg, offset, size, AccessMode>
{
  //using Unclocked = FieldValue<RCC_CR_PLLRDY_Values, BaseType, 0U> ;
  //using Locked = FieldValue<RCC_CR_PLLRDY_Values, BaseType, 1U> ;
  using NotReady = FieldValue<RCC_CR_PLLRDY_Values, BaseType, 0U> ;
  using Ready = FieldValue<RCC_CR_PLLRDY_Values, BaseType, 1U> ;
} ;


При загрузке программы в микроконтроллер наблюдается мигание светодиода с более высокой частотой, чем в предыдущих пунктах.

=== Ответы на вопросы

. `_Что такое POD типы данных?_`
+
*Простая структура данных* (англ. plain old data, POD) — в современных языках программирования высокого уровня тип данных, имеющий жёстко определённое расположение полей в памяти, не требующий ограничения доступа и автоматического управления. Переменные такого типа можно копировать простыми процедурами копирования участков памяти. Противоположность — управляемая структура данных.
+
Проще всего простую структуру данных определить от противного. Если компилятор скрытно от пользователя переставил поля местами или при создании структуры данных скрытно вызывает конструктор, или при уничтожении структуры вызывает деструктор, или при копировании — особую процедуру копирования, то это управляемая (то есть, не простая) структура.
+
К POD-типам в С++ относятся:
+
* все встроенные арифметические типы (включая wchar_t и bool);
* перечисления, т.е. типы, объявленные с помощью ключевого слова enum;
* указатели;
* POD-структуры (struct или class) и POD-объединения (union);

+
Чтобы в С++ структура была POD-типом, она должна удовлетворять следующим требованиям:

* не иметь пользовательских конструкторов, деструктора или копирующего оператора присваивания;
* не иметь базовых классов;
* не иметь виртуальных функций;
* не иметь защищенных (protected) или закрытых (private) нестатических членов данных;
* не иметь не статических членов данных не-POD-типов (или массивов из таких типов), а также ссылок.

. `_Назовите все виды типов в языке С++_`
+
._Классификация типов в С++_
image::file4.png[]
. _Что такое пользовательский тип?_
+
Структура или класс, определенные пользователем, либо определенный пользователем псевдоним к имени некоторого типа.

. `_Назовите модификаторы типов_`.
+
*short*, *long*, *signed*, *unsigned*.

. `_Назовите правило установки размеров типов_`
+
Правило установки типов в С++:
+
[.source, cpp]
----
1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----
. `_Что делает оператор sizeof()?_`
+
Возвращает размер операнда по отношению к размеру типа *char* (то есть, размер операнда в байтах).
+
Результат *sizeof* оператора имеет тип *size_t* (целочисленный беззнаковый тип, определенный в файле *<stddef.h>*).
+
Оператор *sizeof*  не может использоваться со следующими операндами:
+
* функции;
* битовые поля;
* неопределенные классы;
* тип *void*;
* динамически создаваемые массивы;
* внешние массивы;
* неполные типы.

. `_Что характеризует тип std::size_t_`
+
*size_t* представляет собой целое беззнаковое число, характеризующее размер объекта или типа в байтах в конкретной реализации.

. `_Назовите фиксированные типы целых в библиотеке std_`
+
._Типы с фиксированной шириной из <stdint.h>_
image::file5.png[]
. _Что такое псевдоним типа?_
+
Средство, позволяющее программисту создать псевдоним для любого типа данных и использовать его вместо фактического имени типа.

. `_Что такое явное и неявное преобразование типа?_`
+
Неявное преобразование происходит, когда компилятор ожидает значение одного типа, но получает значение другого типа. Явное преобразование происходит, когда программист использует оператор явного преобразования для конвертации значения из одного типа данных в другой.

. `_Какие явные преобразования типов вы знаете?_`
+
В языке C++ есть 5 операторов явного преобразования типов:
+
- *C-style cast*;
- *static_cast*;
- *const_cast*;
- *dynamic_cast*;
- *reinterpret_cast*.

. `_Что делает reinterpret_cast?_`
+
Заставляет интерпретировать битовое представление объекта одного типа как битовое представление объекта другого типа.
. `_Чем static_cast отличается от reinterpret_cast?_`
+
*static_cast* заставляет компилятор искать среди известных ему правил приведения типов подходящее и осуществить его.
+
A *reinterpret_cast* - еще менее типобезопасное  приведение, прямое средство осуществления каламбура типизации.

. `_Что такое ОЗУ и ПЗУ?_`
+
*ОЗУ* - оперативное запоминающее устройство;
+
*ПЗУ* - постоянное запоминающее устройство.
+
*ОЗУ* является энергозависимой памятью,
которая временно хранит файлы, с которыми работаем.
+
*ПЗУ* является энергонезависимой памятью,
которая постоянно хранит служебные команды процессора.

. `_Каков размер памяти ARM Cortex микроконтроллеров?_`
+
Ядро *ARM* имеет 4 Гбайт последовательной памяти с адресов *0x00000000* до *0xFFFFFFFF*.

. `_По какой архитектуре разработан ARM Cortex микроконтроллер?_`
+
По модифицированной Гарвардской архитектуре.

. `_В чем отличие Гарвардской архитектуры от архитектуры фон Неймана?_`
+
Принстонская архитектура, которая часто называется архитектурой фон Неймана, характеризуется использованием общей памяти для хранения команд, данных, а также для организации стека. Для обращения к этой памяти используется общая системная шина, по которой в процессор поступают и команды, и данные.
+
В отличие от Пристонской, Гарвардская архитектура характеризуется физическим разделением памяти команд и памяти данных. В ее оригинальном варианте использовался также отдельный стек. Каждая память соединяется с процессором отдельной шиной, что позволяет одновременно с чтением-записью данных при выполнении текущей команды производить выборку и декодирование следующей команды.

. `_Где располагаются локальные переменные?_`
+
Локальные переменные располагаются в регистрах или на стеке.

. `_Где располагаются статические переменные?_`
+
Инициализированные программой статические переменные хранятся в сегменте *Data*.
+
Не инициализированные программой статические переменные хранятся в сегменте *BSS*.

. `_Где располагаются глобальные переменные?_`
+
Инициализированные программой глобальные переменные хранятся в сегменте *Data*.
+
Не инициализированные программой глобальные переменные хранятся в сегменте *BSS*.
+
. `_Что такое стек?_`
+
*Стек* - абстрактный тип данных, представляющий
собой список элементов, организованных
по принципу *LIFO* (англ. last in -- first out, «последним пришёл — первым вышел»).
+
. `_Что такое указатель?_`
+
Указатель - это переменная, которая хранит адрес другой переменной.

. `_Что такое разыменовывание указателя?_`
+
Разыменовывание указателя - это операция, необходимая для получения значения, записанного в некоторой области памяти, на которую ссылается указатель.

. `_Что означает взятие адреса?_`
+
Взятие адреса объекта - это операция, возвращающая адрес первого байта представления этого объекта в памяти.

. `_Какие операции можно выполнять над указателями?_`
+
Указатели одного типа можно складывать, вычитать, сравнивать.

. `_Что такое константный указатель?_`
+
Константный указатель — это указатель,
значение которого не может быть изменено после инициализации.
+
Для объявления константного указателя используется ключевое слово
*const* между * и именем указателя.

. `_Что такое указатель на константу?_`
+
Указатель на константу — это указатель, который указывает на неизменное значение.
+
Для объявления указателя на константное значение, используется ключевое слово *const* перед типом данных.

. `_Что такое ссылка? В чем её отличие от указателя?_`
+
Ссылку можно считать всегда разыменованым константным указателем.

. `_Что такое регистр?_`
+
Регистр — устройство для записи, хранения и считывания
_n_-разрядных двоичных данных и выполнения других операций над ними.


. `_Что такое регистры общего назначения?_`
+
Регистры общего назначения - это
сверхбыстрая память внутри процессора,
предназначенная для хранения адресов и промежуточных
результатов вычислений (регистр общего назначения/регистр данных)
или данных, необходимых для работы самого процессора.
+
Регистры общего назначения расположены внутри ядра микроконтроллера (сверхбыстрая память).

. `_Что такое регистры специального назначения?_`
+
Регистры специального назначения используются для управления микроконтроллером и его периферией.
+
Регистры специального назначения расположены в *ОЗУ* микроконтроллера.
+
Каждый регистр в архитектуре *ARM* представляет собой ресурс памяти
длиной в 32 бита, где каждый бит можно представить в виде выключателя,
с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

. `_Как можно установить бит в регистре специального назначения?_`
+
reinterpret_cast<uint32_t*>(адрес первого байта регистра)|=1<<(номер бита).

. `_Объясните как вызывается функция._`
+
При вызове функции происходит примерно следующее:
+
* в стек помещается фрейм, содержащий:
 - обратный адрес (адрес инструкции, следующей за вызовом функции);
 - аргументы функции, передаваемые через стек;
 - память под локальные переменные;
 - сохраненные копии всех регистров, модифицированных функцией, которые необходимо будет восстановить после того, как функция завершит свое выполнение.
* в оперативные регистры записываются аргументы функции, передаваемые через них;
* процессор переходит к точке начала выполнения функции.

. `_Что такое трансляция?_`
+
*Трансляция* - это преобразование программы, представленной на одном из языков программирования, в программу на другом языке,
в определенном смысле равносильную первой.

. `_Что такое компоновка?_`
+
*Компоновка* -  связывание между собой объектных файлов, порождаемых компилятором, а также файлов библиотек, входящих в состав системы программирования.

. `_Как лучше организовывать структуру проекта и почему?_`
+
* файловая структура должна отражать структуру пространства имен.
* модули, содержащие логику работы программы, должны быть отделены от аппаратно-зависимых модулей  --  для упрощения портируемости на другие устройства.

. `_Что такое операторы?_`
+
*Оператор* - это символ, который заставляет компилятор выполнить определенную последовательность действий над операндом (операндами).

. `_Какие арифметические операторы вы знаете?_`
+
._Арифметические операторы_
[options="header"]
[cols="4,4,4"]
|=====================
|Операция | Оператор | Комментарий
|Присваивание       | =     | a = b
|Сложение           | +     | a + b
|Вычитание          | -     | a - b
|Унарный плюс       | +     | +a
|Унарный минус      | -     | -a
|Умножение          | *     | a * b
|Деление            | /     | a / b
|Остаток от деления | %     | a % b
|Инкремет  (пост и предфиксный)| ++      | &#43;&#43;a  и  a&#43;&#43;
|Декремент (пост и предфиксный)| - -     | --a и a--
|=====================


. `_Какие логические операторы вы знаете?_`
+
._Логические операторы_
[options="header"]
[cols="4,4,4,7"]
|=====================
|Операция | Оператор | Комментарий | Пример
|Логическое отрицание, НЕ   | !     | !a    |   !true => false
|Логическое умножение, И    | &&    | a && b| true && false => false
|Логическое сложение, ИЛИ   | &#124;&#124;  |   a &#124; &#124;  b  | true &#124; &#124;  false => true
|=====================

. `_Какие побитовые операторы вы знаете?_`
+
._Побитовые операторы_
[options="header"]
[cols="4,4,4,7"]
|=====================
|Операция | Оператор  | Комментарий | Пример
|Побитовая инверсия   | ~     | ~a  | unsigned char a = 0; ~a => 0xFF
|Побитовое И          | &     | a & b | unsigned char a = 1, b = 3; a & b => 1
|Побитовое ИЛИ        | &#124;   | a &#124; b | unsigned char a = 1, b = 3; a &#124; b => 3
|Побитовое исключающее ИЛИ  | ^   | a ^ b | unsigned char a = 1, b = 3; a ^ b => 2
|Побитовый сдвиг влево  | <<   | a << b | unsigned char a = 1, b = 3; a << b => 8
|Побитовый сдвиг вправо | >>   | a >> b | unsigned char a = 8, b = 3; a >> b => 1
|=====================


. `_Приведите пример переопределения оператора_`
+
[source, cpp]
Complex operator +(Complex value)
  {
    return Complex(real+ value.real, imaginary + value.imaginary) ;
  }
+
Примерами переопределённых операторов среди стандартных типов могут служить:
+
* операторы <<, >> для классов-потоков;
* оператор [] для типа std::vector<T>;
* операторы +, += для типа std::string;

+
и т.д.

. `_Какие еще операторы вы знаете?_`
+
\+, -, *, /, %, ^, &, |, ~, !, ,, =, <, >, \<=, >=, ++, –-, <<, >>, ==, !=, &&, ||, +=, -=, /=, %=, ^=, &=, |=, *=, <\<=, >>=, [], (), \->, \-> *, new, new[], delete, delete[].

. `_Как сбросить бит с помощью битовых операторов?_`
+
x &= ~(1 << номер бита).


. `_Как установить бит с помощью битовых операторов?_`
+
x |= 1 << номер бита.


. `_Как поменять значение бита с помощью битовых операторов?_`
+
x ^= 1 << номер бита.

. `_Какой микроконтроллер на отладочной плате XNUCLE ST32F411?_`
+
На плате *XNUCLE ST32F411* размещен микроконтроллер *ST32F411RE*.

. `_Какие блоки входят в состав микроконтроллера STM32F411?_`
+
Функциональные блоки микроконтроллера *STM32F411* представлены на рисунке 6:
+
.Функциональные блоки STM32F411
image::file6.png[]

. `_В чем отличие ядра CortexM4 от CortexM3?_`
+
Основное отличие *M4* от *M3*  --  наличие *DSP*-инструкциями, которые
существенно ускоряет обработку потоковых данных.
+
Возможности *DSP*, входящего в состав *M4*, позволяют
параллельно выполнять четыре операции сложения/вычитания
для 8-ми разрядных чисел или две операции сложения/вычитания
с 16-ти разрядными операндами. Также реализовано умножение за один цикл,
при этом для 16-ти разрядных чисел возможно параллельное исполнение двух операций.

. `_Назовите основные характеристики микроконтроллера STM32F411._`
+
.Характеристики STM32F411
[cols="a, a"]
|===
| *	32 разрядное ядро ARM Cortex-M4 | *	Блок работы с числами с плавающей точкой FPU
| *	512 кБайт памяти программ | *	128 кБайт ОЗУ
| * Встроенный 12 битный 16 канальный АЦП | *	DMA контроллер на 16 каналов
| *	USB 2.0 | *	3x USART
| * 5 x SPI/I2S | * 3x I2C
| * SDIO интерфейс для карт SD/MMC/eMMC | * Аппаратный подсчет контрольной суммы памяти программ CRC
| *	6 - 16 разрядных и 2 - 32 разрядных Таймера | *	1 - 16 битный для управления двигателями
| *	2  сторожевых таймера | *	1 системный таймер
| *	Работа на частотах до 100Мгц |* 81 портов ввода вывода
| *	Питание от 1.7 до 3.6 Вольт | * Потребление 100 мкА/Мгц
|===


. `_Назовите дополнительные характеристики микроконтроллера STM32F411._`
+
- настраиваемые источники тактовой частоты;

- настраиваемые на различные функции порты;

- внутренний температурный сенсор;

- таймеры с настраиваемым модулем ШИМ;

- DMA для работы с модулями (SPI, UART, ADC… );

- 12 разрядный ADC последовательного приближения;

- часы реального времени;

- системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ.

. `_Какие источники тактирования есть у микроконтроллера STM32F411_`
+
Для формирования системной тактовой частоты SYSCLK могут использоваться 3 основных источника:
+
- *HSI* (high-speed internal) — внутренний высокочастотный RC-генератор;
- *HSE* (high-speed external) — внешний высокочастотный генератор;
- *PLL* — система ФАПЧ. Представляет собой набор из умножителей и делителей, тактируется от *HSI* или *HSE*.

+
Также предусмотрены низкочастотные генераторы:

- *LSI* (low-speed internal) — внутренний низкочастотный генератор;
- *LSE* (low-speed external) — внешний низкочастотный генератор.

. `_Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411._`
+
.. Определить какие источники частоты нужны:
+
например, PLL нужен для USB.

.. Включить нужный источник:
+
используя Clock Control register (RCC::CR).
.. Дождаться стабилизации источника:
+
используя соответствующие биты (..RDY) Clock Control register (RCC::CR).

.. Назначить нужный источник на системную частоту:
+
используя Clock Configuration Register (RCC::CFGR).

.. Дождаться пока источник не переключиться на системную частоту:
+
используя Clock Configuration Register (RCC::CFGR).


. `_Что такое ФАПЧ?_`
+
*Фазовая автоподстройка частоты*, *ФАПЧ* - система автоматического регулирования, подстраивающая фазу управляемого генератора так, чтобы она
была равна фазе опорного сигнала, либо отличалась на известную функцию от времени.

. `_Что делает следующий код?_`
+
[source, cpp]
    int main()
    {
        int StudentUdacha = 10;
        int PrepodUdachca = 0 ;
        StudentUdacha =  StudentUdacha ^ PrepodUdachca ;
        PrepodUdachca =  StudentUdacha ^ PrepodUdachca ;
        StudentUdacha ^= PrepodUdachca ;
    }
+
.. Инициализация переменной *StudentUdacha* значением 10.
.. Инициализация переменной *PrepodUdachca* значением 0.
.. Присвоение переменной *StudentUdacha* значения 10|0 = 10.
.. Присвоение переменной *PrepodUdachca* значения 10|0 = 10.
.. Присвоение переменной *StudentUdacha* значения 10|10 = 0.

+
Код обеспечивает обмен переменных значениями  без использования буферной переменной.
